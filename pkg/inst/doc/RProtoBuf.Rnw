\documentclass[11pt]{article}
%\VignetteIndexEntry{RProtoBuf}

\usepackage{url}
\usepackage[colorlinks]{hyperref}
\setlength{\oddsidemargin}{0pt}
\setlength{\textwidth}{17cm} % uh-oh, I use letter :)

<<echo=FALSE,print=FALSE>>=
library( "RProtoBuf" )
rpb.version <- packageDescription( "RProtoBuf" )$Version
@
% closing $ needed here


\author{Romain Fran\c{c}ois \and Dirk Eddelbuettel}
\title{RProtoBuf \Sexpr{rpb.version}: An R API for Protocol Buffers}

\begin{document}
\maketitle

\abstract{
  \noindent
  \textsl{Protocol Buffers} is a software project by Google that is used
  extensively internally and also released under an Open Source license.
  It provides a way of encoding structured data in an efficient yet
  extensible format. Google formally supports APIs for C++, Java and Python.

  This vignette describes version \Sexpr{rpb.version} of the
  \texttt{RProtoBuf} package which brings support for protocol buffer
  messages to R.

}

\section{Protocol Buffers}

Protocol buffers are a language-neutral, platform-neutral, extensible
way of serializing structured data for use in communications
protocols, data storage, and more.

Protocol Buffers offer key features such as an efficient data interchange
format that is both language- and operating system-agnostic yet uses a
lightweight and highly performant encoding, object serialization and
de-serialization as well data and configuration management. Protocol
buffers are also forward compatible: updates to the \texttt{proto}
files do not break programs built against the previous specification.

While benchmarks are not available, Google states on the project page that in
comparison to XML, protocol buffers are at the same time \textsl{simpler},
between three to ten times \textsl{smaller}, between twenty and one hundred
times \textsl{faster}, as well as less ambiguous and easier to program.

The protocol buffers code is released under an open-source (BSD) license. The
protocol buffer project (\url{http://code.google.com/p/protobuf/})
contains a C++ library and a set of runtime libraries and compilers for
C++, Java and Python.

With these languages, the workflow follows standard practice of so-called
Interface Description Languages (IDL)
(c.f. \href{http://en.wikipedia.org/wiki/Interface_description_language}{Wikipedia
  on IDL}).  This consists of compiling a protocol buffer description file
(ending in \texttt{.proto}) into language specific classes that can be used
to create, read, write and manipulate protocol buffer messages. In other
words, given the 'proto' description file, code is automatically generated
for the chosen target language(s). The project page contains a tutorial for
each of these officially supported languages:
\url{http://code.google.com/apis/protocolbuffers/docs/tutorials.html}

Besides the officially supported C++, Java and Python implementations, several projects have been
created to support protocol buffers for many languages. The list of known
languages to support protocol buffers is compiled as part of the
project page: \url{http://code.google.com/p/protobuf/wiki/ThirdPartyAddOns}

\subsection{The address book example}

The protocol buffer project page contains a comprehensive
description of the language: \url{http://code.google.com/apis/protocolbuffers/docs/proto.html}

Through this document, we will use the \texttt{addressbook} example
that is also used by the official tutorials for java, python and C++.

<<echo=F>>=
ab.proto <- system.file( "proto", "addressbook.proto",
	package = "RProtoBuf" )
writeLines( readLines( ab.proto ) )
@

The proto file defines :
\begin{itemize}
\item the message types \texttt{tutorial.Person},
\texttt{tutorial.Person.PhoneNumber} and \texttt{tutorial.AddressBook}
\item the enum type \texttt{tutorial.Person.PhoneType}
\end{itemize}

A message type can contain :
\begin{itemize}
\item A set of fields. For example the \texttt{Person} message type
contains the required field \texttt{name} of primitive type
\texttt{string} associated with the tag number 1.
\item other message type descriptions, for example \texttt{Person}
contains the nested message type \texttt{PhoneNumber}. The fully qualified
type of \texttt{PhoneNumber} is therefore \texttt{tutorial.Person.PhoneNumber}
\item enum type descriptions.
\end{itemize}

\section{Using protocol buffers in R}

This section describes how to use the R API to create and manipulate
protocol buffer messages in R, and how to read and write the
binary \emph{payload} of the messages to files and arbitrary binary
R connections.

\subsection{Importing proto files}

As opposed to other languages (Java, C++, python), the implementation
used by the \texttt{RProtoBuf} package does not rely on the \texttt{protoc}
compiler, which means that no initial step of
statically compiling the proto file into R code is necessary. Instead,
\texttt{proto} files are parsed and processed at runtime by the
protobuf C++ library.

The \texttt{readProtoFiles} function allows importing \texttt{proto}
files in several ways.

<<>>=
args( readProtoFiles )
@

Using the \texttt{file} argument, on can specify one or several file
paths that ought to be proto files.

<<>>=
proto.dir <- system.file( "proto", package = "RProtoBuf" )
proto.file <- file.path( proto.dir, "addressbook.proto" )
readProtoFiles( proto.file )
@

With the \texttt{dir} argument,
ignored if \texttt{file} is supplied, all files matching the
\texttt{.proto} extension will be imported.

<<>>=
dir( proto.dir, pattern = "\\.proto$", full.names = TRUE )
readProtoFiles( dir = proto.dir )
@

Finally, with the
\texttt{package} argument (ignored if \texttt{file} or
\texttt{dir} is supplied), the function will import all \texttt{.proto}
files that are located in the \texttt{proto} sub-directory of the given
package. A typical use for this argument is in the \texttt{.onLoad}
function of a package.

<<>>=
readProtoFiles( package = "RProtoBuf" )
@

Once the proto files are imported, all message descriptors are
are available in the R search path in the \texttt{RProtoBuf:DescriptorPool}
special environment. The mechanism in use is 
described in section~\ref{sec-lookup}.

<<>>=
ls( "RProtoBuf:DescriptorPool" )
@


\subsection{Creating a message}

The objects contained in the special environment are
descriptors for their associated message types. Descriptors will be
discussed in detail in another part of this document, but for the
purpose of this section, descriptors are just used with the \texttt{new}
function to create messages.

<<>>=
p <- new( tutorial.Person, name = "Romain", id = 1 )
@

\subsection{Access and modify fields of a message}

Once the message created, its fields can be quiered
and modified using the dollar operator of R, making protocol
buffer messages seem like lists.

<<>>=
p$name
p$id
p$email <- "francoisromain@free.fr"
@

However, as opposed to R lists, no partial matching is performed
and the name must be given entirely.

The \verb|[[| operator can also be used to query and set fields
of a mesages, supplying either their name or their tag number :

<<>>=
p[["name"]] <- "Romain Francois"
p[[ 2 ]] <- 3
p[[ "email" ]]
@

\subsection{Display messages}

For debugging purposes, protocol buffer messages
implement the \texttt{as.character} method:

<<>>=
writeLines( as.character( p ) )
@

\subsection{Serializing messages}

However, the main focus of protocol buffer messages is
efficiency. Therefore, messages are transported as a sequence
of bytes. The \texttt{serialize} method is implemented for
protocol buffer messages to serialize a message into the sequence of
bytes (raw vector in R speech) that represents the message.

<<>>=
serialize( p, NULL )
@

The same method can also be used to serialize messages to files :

<<>>=
tf1 <- tempfile()
tf1
serialize( p, tf1 )
readBin( tf1, raw(0), 500 )
@

Or to arbitrary binary connections:

<<>>=
tf2 <- tempfile()
con <- file( tf2, open = "wb" )
serialize( p, con )
close( con )
readBin( tf2, raw(0), 500 )
@

\texttt{serialize} can also be used in a more traditionnal
object oriented fashion using the dollar operator :

<<>>=
# serialize to a file
p$serialize( tf1 )
# serialize to a binary connection
con <- file( tf2, open = "wb" )
p$serialize( con )
close( con )
@


\subsection{Parsing messages}

The \texttt{RProtoBuf} package defines the \texttt{read}
function to read messages from files and arbitrary binary connections.

<<>>=
read
@


The binary representation of the message (often called the payload)
does not contain information that can be used to dynamically
infer the message type, so we have to provide this information
to the \texttt{read} function in the form of a descriptor :

<<>>=
message <- read( tutorial.Person, tf1 )
writeLines( as.character( message ) )
@

The \texttt{input} argument of \texttt{read} can also be a binary
readable R connection, such as a binary file connection:

<<>>=
con <- file( tf2, open = "rb" )
message <- read( tutorial.Person, con )
close( con )
writeLines( as.character( message ) )
@

\texttt{read} can also be used as a pseudo method of the descriptor
object :

<<>>=
# reading from a file
message <- tutorial.Person$read( tf1 )
# reading from a binary connection
con <- file( tf2, open = "rb" )
message <- tutorial.Person$read( con )
close( con )
@

\section{Classes, Methods and Pseudo Methods}

The \texttt{RProtoBuf} package uses the S4 system to store
information about descriptors and messages, but the information stored
in the R object is very minimal and mainly consists of an external
pointer to a C++ variable that is managed by the \texttt{proto} C++
library.

<<>>=
str( p )
@

Using the S4 system allows the \texttt{RProtoBuf} package to dispatch
methods that are not generic in the S3 sense, such as \texttt{new}
and \texttt{serialize}.

The \texttt{RProtoBuf} package combines the \emph{R typical} dispatch
of the form \verb|method( object, arguments)| and the more traditionnal
object oriented notation \verb|object$method(arguments)|.

\subsection{messages}

Messages are represented in R using the \texttt{protobufMessage}
S4 class. The class contains the slots \texttt{pointer} and \texttt{type} as
described on the table~\ref{protobufMessage-class-table} :

\begin{table}[h]
\centering
\begin{tabular}{|cp{10cm}|}
\hline
\textbf{slot} & \textbf{description} \\
\hline
\texttt{pointer} & external pointer to the \texttt{Message} object of the C++ proto library. Documentation for the
\texttt{Message} class is available from the protocol buffer project page:
\url{http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.message.html#Message} \\
\hline
\texttt{type} & fully qualified path of the message. For example a \texttt{Person} message
has its \texttt{type} slot set to \texttt{tutorial.Person} \\
\hline
\end{tabular}
\caption{\label{protobufMessage-class-table}Description of slots for the \texttt{protobufMessage} S4 class}
\end{table}

Although the \texttt{RProtoBuf} package uses
the S4 system, the \verb|@| operator is very rarely used. Fields of the
message are retrieved or modified using the \verb|$| or \verb|[[| operators
as seen on the previous section, and pseudo-methods can also
be called using the \verb|$| operator. The table~\ref{protobufMessage-methods-table}
describes the methods defined for the \texttt{protobufMessage} class :

\begin{table}[h]
\centering
\begin{small}
\begin{tabular}{|ccp{8cm}|}
\hline
\textbf{method} & \textbf{section} & \textbf{description} \\
\hline
\texttt{has} & \ref{protobufMessage-method-has} & Indicates if a message has a given field.   \\
\texttt{clone} &  \ref{protobufMessage-method-clone} & Creates a clone of the message \\
\texttt{isInitialized} & \ref{protobufMessage-method-isInitialized} & Indicates if a message has all its required fields set\\
\texttt{serialize} & \ref{protobufMessage-method-serialize} & serialize a message to a file or a binary connection or retrieve the message payload as a raw vector\\
\texttt{clear} & \ref{protobufMessage-method-clear} & Clear one or several fields of a message, or the entire message\\
\texttt{size} & \ref{protobufMessage-method-size} & The number of elements in a message field\\
\texttt{bytesize} & \ref{protobufMessage-method-bytesize} & The number of bytes the message would take once serialized\\
\texttt{swap} & \ref{protobufMessage-method-swap} & swap elements of a repeated field of a message\\
\texttt{set} & \ref{protobufMessage-method-set} & set elements of a repeated field\\
\texttt{fetch} & \ref{protobufMessage-method-fetch} & fetch elements of a repeated field\\
\texttt{str} & \ref{protobufMessage-method-str} & the R structure of the message\\
\texttt{as.character} & \ref{protobufMessage-method-ascharacter} & character representation of a message\\
\texttt{toString} & \ref{protobufMessage-method-toString} & character representation of a message (same as \texttt{as.character}) \\
\texttt{update} & \ref{protobufMessage-method-update} & updates several fields of a message at once\\
\texttt{descriptor} & \ref{protobufMessage-method-descriptor} & get the descriptor of the message type of this message\\
\hline
\end{tabular}
\end{small}
\caption{\label{protobufMessage-methods-table}Description of slots for the \texttt{protobufMessage} S4 class}
\end{table}

\subsubsection{Retrieve fields}
\label{protobufMessage-method-getfield}

The \verb|$| and \verb|[[| operators allow extraction of a field data.

<<keep.source=T>>=
message <- new( tutorial.Person, 
	name = "foo", email = "foo@bar.com", id = 2,
	phone = list( 
		new( tutorial.Person.PhoneNumber, number = "+33(0)...", type = "HOME" ),
		new( tutorial.Person.PhoneNumber, number = "+33(0)###", type = "MOBILE" )
	) )
message$name
message$email
message[[ "phone" ]]
# using the tag number
message[[ 2 ]] # id
@

Neither \verb|$| nor \verb|[[| support partial matching of names. The 
\verb|$| is also used to call methods on the message, and the 
\verb|[[| operator can use the tag number of the field. 

The table~\ref{table-get-types} details correspondance between 
the field type and the type of data that is retrieved by \verb|$| and 
\verb|[[|. 

\begin{table}[h]
\centering
\begin{small}
\begin{tabular}{|c|p{5cm}p{5cm}|}
\hline
field type & R type (non repeated) & R type (repeated) \\
\hline
\hline
double	& \texttt{double} vector & \texttt{double} vector \\
float	& \texttt{double} vector & \texttt{double} vector \\
\hline
int32	  & \texttt{integer} vector & \texttt{integer} vector \\
int64	  & \texttt{integer} vector & \texttt{integer} vector \\
uint32	  & \texttt{integer} vector & \texttt{integer} vector \\
uint64	  & \texttt{integer} vector & \texttt{integer} vector \\
sint32	  & \texttt{integer} vector & \texttt{integer} vector \\
sint64	  & \texttt{integer} vector & \texttt{integer} vector \\
fixed32	  & \texttt{integer} vector & \texttt{integer} vector \\
fixed64	  & \texttt{integer} vector & \texttt{integer} vector \\
sfixed32  & \texttt{integer} vector & \texttt{integer} vector \\
sfixed64  & \texttt{integer} vector & \texttt{integer} vector \\
\hline
bool	& \texttt{logical} vector & \texttt{logical} vector \\
\hline
string	& \texttt{character} vector & \texttt{character} vector \\
bytes	& \texttt{character} vector & \texttt{character} vector \\
\hline
enum & \texttt{integer} vector & \texttt{integer} vector \\
\hline
message & \texttt{S4} object of class \texttt{protobufMessage} & \texttt{list} of \texttt{S4} objects of class \texttt{protobufMessage} \\
\hline
\end{tabular}
\end{small}
\caption{\label{table-get-types}Correspondance between field type and R type retrieved by the extractors.}
\end{table}

\subsubsection{Modify fields}
\label{protobufMessage-method-setfield}

The \verb|$<-| and \verb|[[<-| operators are implemented for 
\texttt{protobufMessage} objects to set the value of a field. The 
R data is coerced to match the type of the message field.

<<>>=
message <- new( tutorial.Person, 
	name = "foo", id = 2 )
message$email <- "foo@bar.com"
message[[ "id" ]] <- 2
message[[ 1 ]] <- "foobar"
writeLines( message$as.character() )
@

The table~\ref{table-message-field-setters} describes the R types that 
are allowed in the right hand side depending on the target type of the 
field. 

\begin{table}[h]
\centering
\begin{small}
\begin{tabular}{|p{5cm}|p{7cm}|}
\hline
internal type & allowed R types \\
\hline
\hline
\texttt{double}, \texttt{float}	& \texttt{integer}, \texttt{raw}, \texttt{double}, \texttt{logical} \\
\hline
\texttt{int32},  \texttt{int64},  \texttt{uint32},  \texttt{uint64},  \texttt{sint32}, 
\texttt{sint64},  \texttt{fixed32},  \texttt{fixed64},  \texttt{sfixed32},  \texttt{sfixed64} 
& 
	\texttt{integer}, \texttt{raw}, \texttt{double}, \texttt{logical} \\
\hline
\texttt{bool} & \texttt{integer}, \texttt{raw}, \texttt{double}, \texttt{logical} \\
\hline
\texttt{bytes}, \texttt{string} & \texttt{character} \\
\hline
\texttt{enum} & \texttt{integer}, \texttt{double}, \texttt{raw}, \texttt{character} \\
\hline
\texttt{message}, \texttt{group} & \texttt{S4}, of class \texttt{protobufMessage} of the appropriate message type, or a \texttt{list} of 
\texttt{S4} objects of class \texttt{protobufMessage} of the appropriate message type.\\
\hline
\end{tabular}
\end{small}
\caption{\label{table-message-field-setters}Allowed R types depending on internal field types. }
\end{table}


\subsubsection{protobufMessage\$has method}
\label{protobufMessage-method-has}

The \texttt{has} method indicates if a field of a message is set. For
repeated fields, the field is considered set if there is at least
on object in the array. For non-repeated fields, the field is considered
set if it has been initialized.

The \texttt{has} method is a thin wrapper around the \texttt{HasField}
and \texttt{FieldSize} methods of the \texttt{google::protobuf::Reflection} C++ class.

<<>>=
message <- new( tutorial.Person, name = "foo" )
message$has( "name" )
message$has( "id" )
message$has( "phone" )
@

\subsubsection{protobufMessage\$clone method}
\label{protobufMessage-method-clone}

The \texttt{clone} function creates a new message that is a clone
of the message. This function is a wrapper around the methods \texttt{New}
and \texttt{CopyFrom} of the \texttt{google::protobuf::Message} C++ class.

<<>>=
m1 <- new( tutorial.Person, name = "foo" )
m2 <- m1$clone( )
m2$email <- "foo@bar.com"
writeLines( as.character( m1 ) )
writeLines( as.character( m2 ) )
@

\subsubsection{protobufMessage\$isInitialized method}
\label{protobufMessage-method-isInitialized}

The \texttt{isInitialized} method quickly checks
if all required fields have values set. This is a thin wrapper
around the \texttt{IsInitialized} method of the
\texttt{google::protobuf::Message} C++ class.

<<>>=
message <- new( tutorial.Person, name = "foo" )
message$isInitialized()
message$id <- 2
message$isInitialized()
@

\subsubsection{protobufMessage\$serialize method}
\label{protobufMessage-method-serialize}

The \texttt{serialize} method can be used to serialize
the message as a sequence of bytes into a file or a binary connection.

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
tf1 <- tempfile( )
tf1
message$serialize( tf1 )

tf2 <- tempfile( )
tf2
con <- file( tf2, open = "wb" )
message$serialize( con )
close( con )
@

The files \Sexpr{basename(tf1)} and \Sexpr{basename(tf2)} both
contain the message payload as a sequence of bytes. The \texttt{readBin}
function can be used to read the files as a raw vector in R:

<<>>=
readBin( tf1, raw(0), 500 )
readBin( tf2, raw(0), 500 )
@

The \texttt{serialize} method can also be used to directly retrieve the
payload of the message as a raw vector:

<<>>=
message$serialize(NULL)
@

\subsubsection{protobufMessage\$clear method}
\label{protobufMessage-method-clear}

The \texttt{clear} method can be used to clear all fields of a
message when used with no argument, or a given field.

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
writeLines( as.character( message ) )
message$clear()
writeLines( as.character( message ) )

message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
message$clear( "id" )
writeLines( as.character( message ) )
@

The \texttt{clear} method is a thin wrapper around the
\texttt{Clear} method of the \texttt{google::protobuf::Message} C++ class.


\subsubsection{protobufMessage\$size method}
\label{protobufMessage-method-size}

The \texttt{size} method is used to query the number of objects
in a repeated field of a message :

<<keep.source=T>>=
message <- new( tutorial.Person, name = "foo",
	phone = list(
		new( tutorial.Person.PhoneNumber, number = "+33(0)...", type = "HOME"  ),
		new( tutorial.Person.PhoneNumber, number = "+33(0)###", type = "MOBILE"  )
		) )
message$size( "phone" )
size( message, "phone" )
@

The \texttt{size} method is a thin wrapper around the \texttt{FieldSize}
method of the \texttt{google::protobuf::Reflection} C++ class.


\subsubsection{protobufMessage\$bytesize method}
\label{protobufMessage-method-bytesize}

The \texttt{bytesize} method retrieves the number of bytes the message
would take once serialized. This is a thin wrapper around the \texttt{ByteSize}
method of the \texttt{google::protobuf::Message} C++ class.

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
message$bytesize()
bytesize( message )
length( message$serialize( NULL ) )
@

\subsubsection{protobufMessage\$swap method}
\label{protobufMessage-method-swap}

The \texttt{swap} method can be used to swap elements
of a repeated field.

<<keep.source=T>>=
message <- new( tutorial.Person, name = "foo",
	phone = list(
		new( tutorial.Person.PhoneNumber, number = "+33(0)...", type = "HOME"  ),
		new( tutorial.Person.PhoneNumber, number = "+33(0)###", type = "MOBILE"  )
		) )
message$swap( "phone", 1, 2 )
writeLines( as.character( message$phone[[1]] ) )
writeLines( as.character( message$phone[[2]] ) )

swap( message, "phone", 1, 2 )
writeLines( as.character( message$phone[[1]] ) )
writeLines( as.character( message$phone[[2]] ) )
@


\subsubsection{protobufMessage\$set method}
\label{protobufMessage-method-set}

The \texttt{set} method can be used to set values
of a repeated field. 

<<keep.source=T>>=
message <- new( tutorial.Person, name = "foo",
	phone = list(
		new( tutorial.Person.PhoneNumber, number = "+33(0)...", type = "HOME"  ),
		new( tutorial.Person.PhoneNumber, number = "+33(0)###", type = "MOBILE"  )
		) )
number <- new( tutorial.Person.PhoneNumber, 
		number = "+33(0)---", type = "WORK"  ) 
message$set( "phone", 1, number )
writeLines( as.character( message ) )
@

\subsubsection{protobufMessage\$fetch method}
\label{protobufMessage-method-fetch}

The \texttt{fetch} method can be used to set values
of a repeated field. 

<<keep.source=T>>=
message <- new( tutorial.Person, name = "foo",
	phone = list(
		new( tutorial.Person.PhoneNumber, number = "+33(0)...", type = "HOME"  ),
		new( tutorial.Person.PhoneNumber, number = "+33(0)###", type = "MOBILE"  )
		) )
message$fetch( "phone", 1 )
@


\subsubsection{protobufMessage\$str method}
\label{protobufMessage-method-str}

The \texttt{str} method gives the R structure of the message. This is rarely
useful.

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
message$str()
str( message )
@

\subsubsection{protobufMessage\$as.character method}
\label{protobufMessage-method-ascharacter}

The \texttt{as.character} method gives the debug string of the message.

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
writeLines( message$as.character() )
writeLines( as.character( message ) )
@

\subsubsection{protobufMessage\$toString method}
\label{protobufMessage-method-toString}

\texttt{toString} currently is an alias to the \texttt{as.character} function.

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
writeLines( message$toString() )
writeLines( toString( message ) )
@


\subsubsection{protobufMessage\$as.list method}
\label{protobufMessage-method-aslist}

The \texttt{as.list} method converts the message to an named R list

<<>>=
message <- new( tutorial.Person, name = "foo", email = "foo@bar.com", id = 2 )
as.list( message )
@

The names of the list are the names of the declared fields of the
message type, and the content is the same as can be extracted with
the \verb|$| operator described in
section~\ref{protobufMessage-method-getfield}.

\subsubsection{protobufMessage\$update method}
\label{protobufMessage-method-update}

The \texttt{update} method can be used to update several fields
of a message at once.

<<keep.source=TRUE>>=
message <- new( tutorial.Person )
update( message,
	name = "foo",
	id = 2,
	email = "foo@bar.com" )
writeLines( message$as.character() )
@

\subsubsection{protobufMessage\$descriptor method}
\label{protobufMessage-method-descriptor}

The \texttt{descriptor} method retrieves the
descriptor of a message. See section~\ref{subsec-descriptor}
for more information about message type descriptors.

<<>>=
message <- new( tutorial.Person )
message$descriptor()
descriptor( message )
@


\subsection{message descriptors}
\label{subsec-descriptor}

Message descriptors are represented in R with the
\emph{protobufDescriptor} S4 class. The class contains
the slots \texttt{pointer} and \texttt{type} :

\begin{table}[h]
\centering
\begin{tabular}{|cp{10cm}|}
\hline
\textbf{slot} & \textbf{description} \\
\hline
\texttt{pointer} & external pointer to the \texttt{Descriptor} object of the C++ proto library. Documentation for the
\texttt{Descriptor} class is available from the protocol buffer project page:
\url{http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.descriptor.html#Descriptor} \\
\hline
\texttt{type} & fully qualified path of the message type. \\
\hline
\end{tabular}
\caption{\label{protobufDescriptor-class-table}Description of slots for the \texttt{protobufDescriptor} S4 class}
\end{table}

Similarly to messages, the \verb|$| operator can be used to extract
information from the descriptor, or invoke pseuso-methods.

\subsubsection{Extracting descriptors}

The \verb|$| operator, when used on a descriptor object retrieves
descriptors that are contained in the descriptor.

This can be a field descriptor (see section~\ref{subsec-field-descriptor} ),
an enum descriptor (see section~\ref{subsec-enum-descriptor}) or a descriptor
for a nested type

<<>>=
# field descriptor
tutorial.Person$email

# enum descriptor
tutorial.Person$PhoneType

# nested type descriptor
tutorial.Person$PhoneNumber
# same as
tutorial.Person.PhoneNumber
@

\subsubsection{The new method}

The \texttt{new} method creates a prototype of a message
described by the descriptor.

<<>>=
tutorial.Person$new( )
new( tutorial.Person )
@

Passing additional arguments to the method allows to directlt set
the fields of the message at construction time.

<<>>=
tutorial.Person$new( email = "foo@bar.com" )

# same as
update( tutorial.Person$new( ), email = "foo@bar.com" )
@

\subsubsection{The read method}

The \texttt{read} method is used to read a message
from a file or a binary connection.

<<>>=
# start by serializing a message
message <- new( tutorial.Person.PhoneNumber,
	type = "HOME", number = "+33(0)...." )
tf <- tempfile()
serialize( message, tf )

# now read back the message
m <- tutorial.Person.PhoneNumber$read( tf )
writeLines( as.character( m ) )

m <- read( tutorial.Person.PhoneNumber, tf )
writeLines( as.character( m ) )
@


\subsection{field descriptors}
\label{subsec-field-descriptor}

The class \emph{protobufFieldDescriptor} represents field
descriptor in R. This is a wrapper S4 class around the
\texttt{google::protobuf::FieldDescriptor} C++ class.

\begin{table}[h]
\centering
\begin{tabular}{|cp{10cm}|}
\hline
\textbf{slot} & \textbf{description} \\
\hline
\texttt{pointer} & External pointer to the \texttt{FieldDescriptor} C++ variable \\
\hline
\texttt{name} & simple name of the field \\
\hline
\texttt{full\_name} & fully qualified name of the field \\
\hline
\texttt{type} & name of the message type where the field is declared \\
\hline
\end{tabular}
\caption{\label{protobufFieldDescriptor-class-table}Description of slots for the \texttt{protobufFieldDescriptor} S4 class}
\end{table}

\subsubsection{as.character}

The \texttt{as.character} method brings the debug string of the field descriptor.

<<>>=
writeLines( as.character( tutorial.Person$PhoneNumber ) )
@

\subsection{enum descriptors}
\label{subsec-enum-descriptor}

The class \emph{protobufEnumDescriptor} is an R wrapper
class around the C++ class \texttt{google::protobuf::EnumDescriptor}.

\begin{table}[h]
\centering
\begin{tabular}{|cp{10cm}|}
\hline
\textbf{slot} & \textbf{description} \\
\hline
\texttt{pointer} & External pointer to the \texttt{EnumDescriptor} C++ variable \\
\hline
\texttt{name} & simple name of the enum \\
\hline
\texttt{full\_name} & fully qualified name of the enum \\
\hline
\texttt{type} & name of the message type where the enum is declared \\
\hline
\end{tabular}
\caption{\label{protobufEnumDescriptor-class-table}Description of slots for the \texttt{protobufEnumDescriptor} S4 class}
\end{table}

\subsubsection{as.list}

The \texttt{as.list} method creates a named R integer vector that
captures the values of the enum and their names.

<<>>=
as.list( tutorial.Person$PhoneType )
@

\subsubsection{as.character}

The \texttt{as.character} method brings the debug string of the enum type.

<<>>=
writeLines( as.character( tutorial.Person$PhoneType ) )
@

\section{Utilities}

\subsection{completion}

The \texttt{RProtoBuf} package implements the
\texttt{.DollarNames} S3 generic function
(defined in the \texttt{utils} package) for all classes.

Completion possibilities include pseudo method names for all
classes, plus :
\begin{itemize}
\item field names for messages
\item field names, enum types, nested types for message type descriptors
\item names for enum descriptors
\end{itemize}

\subsection{with and within}

The S3 generic \texttt{with} function is implemented for class
\texttt{protobufMessage}, allowing to evaluate an R expression in
an environment that allows to retrieve and set fields of a message
simply using their names.

<<>>=
message <- new( tutorial.Person, email = "foo@bar.com" )
with( message, {
	# set the id field
	id <- 2

	# set the name field from the email field
	name <- gsub( "[@]", " ", email )

	sprintf( "%d [%s] : %s", id, email, name )
} )
@

The difference between \texttt{with} and \texttt{within} is the value
that is returned. For \texttt{with} returns the result of the R expression,
for \texttt{within} the message is returned. In both cases, the message
is modified because \texttt{RProtoBuf} works by reference.

\subsection{merge}

\texttt{merge} can be used to merge two messages of the same type.

<<>>=
m1 <- new( tutorial.Person, name = "foobar" )
m2 <- new( tutorial.Person, email = "foo@bar.com" )
m3 <- merge( m1, m2 )
writeLines( as.character( m3 ) )
@

\subsection{P}

The \texttt{P} function is an alternative way to retrieve
a message descriptor using its type name. It is not often used because
of the lookup mechanism described in section~\ref{sec-lookup}.

<<>>=
P("tutorial.Person")
new( P("tutorial.Person") )

# but we can do this instead
tutorial.Person
new( tutorial.Person )
@

\section{Descriptor lookup}
\label{sec-lookup}

The \texttt{RProtoBuf} package uses the user defined tables framework
that is defined as part of the \texttt{RObjectTables} package available
from the OmegaHat project.

The feature allows \texttt{RProtoBuf} to install the
special environment \emph{RProtoBuf:DescriptorPool} in the R search path.
The environment is special in that, instead of being associated with a
static hash table, it is dynamically queried by R as part of R's usual
variable lookup. In other words, it means that when the R interpreter
looks for a binding to a symbol (foo) in its search path,
it asks to our package if it knows the binding "foo", this is then
implemented by the \texttt{RProtoBuf} package by calling an internal
method of the \texttt{protobuf} C++ library.

\section{Plans for future releases}

Saptarshi Guha wrote another package that deals with integration 
of protocol buffer messages with R, taking a different angle : 
serializing any R object as a message, based on a single catch-all 
\texttt{proto} file. We plan to integrate this functionality into 
\texttt{RProtoBuf}. Saptarshi's package is available at 
\url{http://ml.stat.purdue.edu/rhipe/doc/html/ProtoBuffers.html}

Protocol buffers have a mechanism for remote procedure calls (rpc) 
that is not yet used by \texttt{RProtoBuf}, but we plan to 
take advantage of this by writing a protocol buffer message R server, 
and client code as well, probably based on the functionality 
of the \texttt{Rserve} package.

% \section{Troubleshouting}

\section{Acknowledgments}

% protobuf ?
% saptarshi ?

Some of the design of the package is based on the design of the 
\texttt{rJava} package by Simon Urbanek (dispatch on new, S4 class 
structures using external pointers, etc ...). We'd like to thank
Simon for his indirect involvment on \texttt{RProtoBuf}. 

The user defined table mechasnism, implemented by Duncan Temple Lang
for the purpose of the \texttt{RObjectTables} package allowed the 
dynamic symbol lookup (see section~\ref{sec-lookup}). Many thanks 
to Duncan for this amazing feature. 


\end{document}

